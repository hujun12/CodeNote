##### TCP/IP五层协议

- 应用层 ：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。
- 传输层：负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：
  - TCP：提供面向连接的、可靠的数据传输服务。
  - UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。
- 网络层（IP层）：负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。
- 数据链路层：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。
- 物理层：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。



##### UDP

- 面向无连接
  - UDP 不需要和 TCP 一样在发送数据前进行三次握手建立连接，想发数据就可以发送
  - 只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作
  - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了。在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会做任何拼接操作。

- 不可靠性
  - 不可靠性体现在无连接上
  - 收到什么数据就传递什么数据，也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了
  - 网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。
- 高效
  - UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。
- 传输方式
  - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
- 应用：直播、电话会议、游戏等



##### TCP

- 特点
  - 面向连接：发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”。
  - 仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
  - 全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段。最大的数据段大小取决于MSS（TCP 允许的从对方接收的最大报文段）。
  - 面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
  - 可靠传输：对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的**按序接收**。然后接收端实体对已成功收到的字节发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据（假设丢失了）将会被**重传**。
  - 超时重传：只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。否则，进行重传。大于RTT的平均时间。
  - 流量控制：TCP两端都维护着窗口：发送端窗口和接收端窗口。发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据，由接收窗口剩余大小决定的，不断变化。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。
  - 拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。

- 三次握手
  - 第一次握手：客户端向服务端发送**连接请求报文段**。该报文段中包含自身的**初始序号**。请求发送后，客户端便进入 **SYN-SENT** 状态。
  - 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个**应答**，该应答中也会包含自身的**初始序号**，发送完成后便进入 **SYN-RECEIVED** 状态。
  - 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个**确认报文**。客户端发完这个报文段后便进入 **ESTABLISHED** 状态，服务端收到这个应答后也进入 **ESTABLISHED** 状态，此时连接建立成功。确认报文的ACK报文段可以携带数据，不携带数据则不消耗序号。
  
  <img src="C:\Users\hujun\Desktop\codeNote\img\tcp.jpg" style="zoom: 67%;" />
  
  - 为什么两次不行？
    - 为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。
    - 客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。
    - 假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。
  
- 四次挥手
  - 第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送**连接释放请求**。
  - 第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 **ACK 包**，并进入 **CLOSE_WAIT** 状态，此时表明**客户端到服务端的连接已经释放**，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。
  - 第三次挥手：**服务端如果此时还有没发完的数据**会继续发送，完毕后会向客户端发送**连接释放请求**，然后服务端便进入 **LAST-ACK** 状态。
  - 第四次挥手：客户端收到释放请求后，向服务端发送**确认应答**，此时客户端进入 **TIME-WAIT** 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 **CLOSED** 状态。当服务端收到确认应答后，也便进入 **CLOSED** 状态。
  
  <img src="C:\Users\hujun\Desktop\codeNote\img\tcp2.jpg" style="zoom: 67%;" />
  
  - 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？
    - 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。
  - 为什么需要四次？
    - 关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，不能一起发送，故需要四次挥手。



##### DNS

- 概念：域名系统。提供了一种主机名到 IP 地址的转换服务，是一个由分层的 DNS 服务器组成的分布式数据库。DNS协议是一个定义了主机如何查询这个分布式数据库的方式的应用层协议。

- DNS同时使用TCP和UDP协议
  - 在区域传输的时候使用TCP协议，域名服务器之间
  - 在域名解析的时候使用UDP协议

- DNS解析过程

  - DNS缓存：浏览器、操作系统、LDNS、根域名服务器都会对DNS结果做一定程度的缓存；

  - 在浏览器缓存、操作系统缓存、hosts中依次查询；

  - 向LDNS（本地DNS服务器）发起域名解析请求（UDP协议），若LDNS有缓存，直接返回；

  - 常规流程

    <img src="C:\Users\hujun\Desktop\codeNote\img\DNS解析1.jpg" style="zoom: 33%;" />

  - CDN流程：请求cdn相关域名下的资源

    <img src="C:\Users\hujun\Desktop\codeNote\img\DNS解析2.jpg" style="zoom:50%;" />

- DNS prefetch

  - 提前解析之后可能会用到的域名，使解析结果缓存到操作系统缓存中，缩短DNS解析时间，进而提高网站的访问速度。
  - 如果某一时间内，有多个请求都发送给同一个服务器，那么DNS解析会多次并且重复触发。这样会导致整体的网页加载有延迟的情况。
  - 假如浏览器首次将一个域名解析为IP地址，并缓存至操作系统，那么下一次DNS解析时间可以低至0-1ms。倘若结果不缓存在系统，那么就需要读取路由器的缓存，进而后续的解析时间最小也要约15ms。
  
  ```html
  <!-- 仅对跨域域上的 DNS 查找有效 -->
  <link rel="dns-prefetch" href="https://fonts.gstatic.com/">
  <!-- 预连接，会建立与服务器的连接，仅用于最关键的连接 -->
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
  ```



##### URL对象

- 创建

  ```js
  //1.2相同
  let url1 = new URL('https://javascript.info/profile/admin'); 1
  let url2 = new URL('/profile/admin', 'https://javascript.info'); 2
  ```

- 属性

  ```js
  "https://site.com:8080/path/page?p1=v1&p2=v2#hash"
  URL {
    href: 'https://site.com:8080/path/page?p1=v1&p2=v2#hash',
    origin: 'https://site.com:8080',
    protocol: 'https:',
    username: '',
    password: '',
    host: 'site.com:8080',
    hostname: 'site.com',
    port: '8080',
    pathname: '/path/page',
    search: '?p1=v1&p2=v2',
    searchParams: URLSearchParams { 'p1' => 'v1', 'p2' => 'v2' },
    hash: '#hash'
  }
  //searchParams：append、delete、get、getAll、has、set、可迭代
  ```

- 字符串url编码

  ```js
  //encodeURI：不会编码&，#等字符
  //编码url整体使用
  let url = encodeURI('http://site.com/привет');
  // 解码
  decodeURI(url)
  
  //encodeURIComponent：编码所有字符
  //编码url参数使用
  let music = encodeURIComponent('Rock&Roll');
  let url = `https://google.com/search?q=${music}`
  // 解码
  decodeURIComponent(music)
  ```



##### HTTP

- http请求场景

  - 输入url、点击a标签
  - img、css、script、video、audio等静态资源
  - form表单提交：get/post（页面会跳转）
  - ajax：支持所有请求类型
- 特点

  - 灵活可拓展。语义自由，传输形式多样
  - 基于TCP，传输可靠
  - 请求-应答。一收一发，有来有回
  - 无状态。每次请求都是独立、无关的，不保留状态信息
- 缺点
  - 无状态
  - 明文传输（报文），不安全
  - 队头阻塞


- 请求报文

  - 请求行：请求类型（POST）+ URL路径 + HTTP版本（1.1） GET /home HTTP/1.1
  - 请求头：Host、Cookie、Content-type、User-Agent等

  - 空行

  - 请求体（GET可为空）：username=admin&password=123456
- 响应报文
  - 响应行：HTTP版本 + HTTP状态码（状态字符串）  HTTP/1.1 200 OK
  - 响应头：Content-type、Content-length、Content-encoding等
  - 空行
  - 响应体：返回的结果
- 请求类型
  - GET：获取数据
  - POST：提交数据
  - PUT：更新数据
  - DELETE：删除数据
  - HEAD：请求页面头部
  - OPTIONS：列出可对资源实行的请求方法，用来跨域请求
  - TRACE：追踪请求-响应的传输路径
  - CONNECT：建立连接隧道，用于代理服务器



##### 请求头与响应头

- set-cookie：响应头，设置cookie

- MIME type
  - text：text/html, text/plain, text/css 等
  - image： image/gif, image/jpeg, image/png 等
  - audio/video：audio/mpeg, video/mp4 等
  - application：application/json，application/javascript，application/pdf，application/octet-stream，application/x-www-form-urlencoded
  - multipart/form-data

- Accept（请求头）
  - Accept：想要接收特定类型的数据（MIME type）
  - Accept-Encoding：压缩方式（gzip、deflate、br）
  - Accept-Charset：字符集（charset=utf-8）
  - Accept-Language

- Content：请求（响应）头，设置请求（响应）体内容
  - Content-type：MIME type
  - Content-Encoding

- 表单提交的Content-Type
  - application/x-www-form-urlencoded
    
    ```js
    {a: 1, b: 2}
    a=1&b=2   // 数据会被编码成以&分隔的键值对
    "a%3D1%26b%3D2"  // 并以URL编码方式编码
    ```
    
  - multipart/form-data
    
    ```js
    Content-Disposition: form-data;name="data1";
    Content-Type: text/plain
    data1
    ----WebkitFormBoundaryRRJKeWfHPGrS4LKe  // boundary
    
    Content-Disposition: form-data;name="data2";
    Content-Type: text/plain
    data2
    ----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
    ```



##### http状态码

- 1xx：继续
  - post请求，先发送http header，服务端返回此信息，表示确认，之后发送请求体等

- 2xx：成功
  - 200(OK) ：正常返回信息
  - 206(Partial Content)：表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。
- 3xx：需要进行附加操作一完成请求
  - 301(moved permanently)：永久性重定向，请求的网页已永久移动到新位置
  - 302(found)：临时性重定向
  - 303(See Other)：临时性重定向，应使用 GET 进行请求
  - 304(Not Modified)：协商缓存生效
- 4xx：客户端错误状态码
  - 400(Bad Request)：请求报文存在语法错误
  - 401(unauthorized)：请求未授权
  - 403(Forbidden)：请求资源的访问被服务器拒绝
  - 404(Not Found)：在服务器上没有找到请求的资源
- 5xx：服务器错误状态码
  - 500(Internal Server Error)：表示服务器端在执行请求时发生了错误
  - 503(Service Unavailable)：服务器端暂时无法处理请求（可能是过载或维护）



##### http1.1/2.0

- Connection：keep-alive（长连接）
  - HTTP/1.1的Connection默认为keep-alive，完成一个http请求后不会立即断开
  - 请求头和响应头中都有
  - Keep-Alive不会永久保持连接，它有一个保持时间，可以在服务器设定这个时间
  - 优点
    - 较少的CPU和内存的使用（由于同时打开的连接的减少了）
    - 允许请求和应答的HTTP管线化
    -  降低拥塞控制 （TCP连接减少了）
    - 减少了后续请求的延迟（无需再次握手）
    - 报告错误无需关闭TCP连接
- 队头阻塞
  - HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收。里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。
  - 域名分片：增加很多二级域名
  - HTTP1.1：并发连接。浏览器会同时与服务器建立多个TCP连接（chrome6个），来支持多个HTTP同时请求
  - HTTP/2.0：多路复用。同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。

- HTTP1.1
  - 长连接
  - 浏览器缓存相关
  - 请求方法，PUT、HEAD、OPTIONS 等
  - 允许只请求资源的某个部分，返回码206
  - hosts字段，多个虚拟主机共享一个IP地址

- HTTP2.0
  - 请求头压缩：HPACK 算法
    - 在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中。传输的时候只需要把**索引**(比如0，1，2，...)传给对方即可。
    - 对于整数和字符串进行哈夫曼编码。
    
  - 多路复用

    - 二进制分帧：Headers + Body的报文格式被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。
    - 服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。并且一个 HTTP/2 连接上可以同时发多个帧。
    - 所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。
    - 流：通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列叫做流。
    - 多路复用：HTTP/2 用流来在**一个 TCP 连接**上来进行多个数据帧的通信。

  - 服务器推送（Server Push）

    服务器能新建 stream 来给客户端发送消息。当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 **HTML 中引用到的其他资源文件**一起返回给客户端，减少客户端的等待。



##### HTTPS

- https：http 是超文本传输协议，信息是明文传输，https协议要比 http 协议安全，https 具有安全性的SSL/TLS 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。

- TLS/SSL：安全层传输协议。是介于TCP和HTTP之间的一层安全协议，目前的主流版本是TLS/1.2。安全层的主要职责就是对发起的HTTP请求的数据进行加密操作和对接收到的HTTP的内容进行解密操作。

- 加密过程
  - 对称加密：加密和解密使用同一个密钥
  - 非对称加密
    - 私钥加密后的密文，可以用公钥解密，但是反过来公钥加密后的密文，只有私钥可以解密
    - 公钥是开放给所有人的，但私钥是需要保密的，存在于服务端
    - 服务器端server向client端的信息传输是不安全的：因为所有人都可以获取公钥
    - client端向server端的信息传输是安全的：因为私钥只有server端存在
  - 如何安全的获取公钥：使用证书
  - 证书认证
    - 浏览器拿到数字证书后。首先会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，用这个函数来计算明文内容得到信息A，然后用公钥解密明文内容得到信息B，两份信息做比对，一致则表示认证合法。
  
- HTTPS的通信过程
  
  <img src="C:\Users\hujun\Desktop\codeNote\img\https.jpg" style="zoom: 67%;" />
  
- 优点
  - 可以认证用户和服务器，确保数据发送到正确的客户端和服务器
  - 可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性
  - https是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本
  
- 缺点
  - HTTPS需要做服务器和客户端双方的加密和解密处理，耗费更多服务器资源，过程复杂
  - HTTPS协议握手阶段比较费时，增加页面的加载时间
  - SSL证书是收费的，功能越强大的证书费用越高
  - HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本
  - SSL证书需要绑定IP，不能在同一个IP上绑定多个域名
  
- 中间人攻击
  - 攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。
  - 没有进行严格的证书校验是中间人攻击着手点。
  - 解决方法：使用可靠的证书。
